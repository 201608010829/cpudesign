# 实验报告 未完成

## 实验名称（RISC-V的基本整数指令集RV32I的CPU设计）

班级：信安1602

学号：201608060230

姓名：陈卓

## 实验目标

完成一个执行RISC-V的基本整数指令集RV32I的CPU设计（单周期实现）。

## 实验要求

- 硬件设计采用VHDL或Verilog语言，软件设计采用C/C++或SystemC语言，其它语言例如Chisel、MyHDL等也可选。

- 实验报告采用markdown语言，或者直接上传PDF文档

- 实验最终提交所有代码和文档



## 实验内容

### CPU指令集

CPU的指令集请见[这里](https://riscv.org/specifications/)，其中基本指令集共有47条指令。


### 程序框架

这里我先说明一下CPU的整个框架。
如图所示
![](https://github.com/luojike/cpudesign/blob/master/2019/陈卓_陈德飞/201608060230_陈卓/实验报告/rpu_core_diagram.png)

其次是工程结构，在工程文件夹下面的已经粗略介绍过，这里再说一下。
![](https://github.com/luojike/cpudesign/blob/master/2019/陈卓_陈德飞/201608060230_陈卓/实验报告/VHDL文件结构.png)
首先constants.vhd文件定义了工程中要使用的各个常量，并且将其打包成package，方便后面的vhdl文件使用。
入参定义如下，包括了输入输出、时钟、重置等信号。

```vhdl
entity cpu is
	port(
		clk: in std_logic;
		reset: in std_logic;
		inst_addr: out std_logic_vector(31 downto 0);
		inst: in std_logic_vector(31 downto 0);
		data_addr: out std_logic_vector(31 downto 0);
		data_in: in std_logic_vector(31 downto 0);
		data_out: out std_logic_vector(31 downto 0);
		data_read: out std_logic;
		data_write: out std_logic
	);
end entity cpu;
```

architecture部分，声明了计算是需要使用的变量。ir表示当前执行的指令，pc表当前的指令的地址；7位的opcode，3位的funct3，7位的funct7，这三个变量读取ir的指令，取到对应的值。寄存器rd,rs1,rs2存储ir中读取到的对应操作值地址，src1,src2将rs1,rs2中的地址对于的reg中的值转为32位保存。Imm11_0I、Imm20_1J、Imm11_0S、Imm12_1B是三种不同类型的指令下立即数的拓展。



```vhdl
			signal ir: std_logic_vector(31 downto 0);
		signal pc: std_logic_vector(31 downto 0);

		signal next_pc: std_logic_vector(31 downto 0);

		-- Fields in instruction
		signal opcode: std_logic_vector(6 downto 0);
		signal rd: std_logic_vector(4 downto 0);
		signal funct3: std_logic_vector(2 downto 0);
		signal rs1: std_logic_vector(4 downto 0);
		signal rs2: std_logic_vector(4 downto 0);
		signal funct7: std_logic_vector(6 downto 0);
		
		signal Imm11_0I : std_logic_vector(31 downto 0);
		signal Imm20_1J : std_logic_vector(31 downto 0);
		signal Imm12_1B : std_logic_vector(31 downto 0); 
		signal Imm11_0S : std_logic_vector(31 downto 0);
		
		signal src1: std_logic_vector(31 downto 0);
		signal src2: std_logic_vector(31 downto 0);
		signal subresult: std_logic_vector(31 downto 0);
        
		signal sb_d1: std_logic_vector(31 downto 0);
		signal sb_a1: std_logic_vector(31 downto 0);
		
		signal jalresult: std_logic_vector(31 downto 0);
		signal blturesult: std_logic_vector(31 downto 0);
		signal sbresult: std_logic_vector(31 downto 0);
		signal xoriresult: std_logic_vector(31 downto 0);
		signal addresult: std_logic_vector(31 downto 0);

		type regfile is array(natural range<>) of std_logic_vector(31 downto 0);
		signal regs: regfile(31 downto 0);
		signal reg_write: std_logic;
		signal reg_write_id: std_logic_vector(4 downto 0);
		signal reg_write_data: std_logic_vector(31 downto 0);
```


取出各个值，拼凑指令要求的立即数：

```vhdl
		inst_addr <= pc;
		ir <= inst;

		-- Decode
		-- Not finished
		opcode <= ir(6 downto 0);
		rd <= ir(11 downto 7);
		funct3 <= ir(14 downto 12);
		rs1 <= ir(19 downto 15);
		rs2 <= ir(24 downto 20);
		funct7 <= ir(31 downto 25);
		
		Imm11_0I <= "11111111111111111111" & ir(31 downto 20) when ir(31)='1' else
									"00000000000000000000" & ir(31 downto 20);
    	Imm20_1J <= "111111111111" & ir(31) & ir(19 downto 12) & ir(20) & ir(30 downto 21) when ir(31)='1' else
									"000000000000" & ir(31) & ir(19 downto 12) & ir(20) & ir(30 downto 21);
    	Imm11_0S <= "11111111111111111111" & ir(31 downto 25) & ir(11 downto 7) when ir(31)='1' else
									"00000000000000000000" & ir(31 downto 25) & ir(11 downto 7);
    	Imm12_1B <= "11111111111111111111" & ir(31) & ir(7) & ir(30 downto 25) & ir(11 downto 8) when ir(31)='1' else
									"00000000000000000000" & ir(31) & ir(7) & ir(30 downto 25) & ir(11 downto 8);
				-- Read operands from register file
		src1 <= regs(TO_INTEGER(UNSIGNED(rs1)));
		src2 <= regs(TO_INTEGER(UNSIGNED(rs2)));
		
		sb_d1 <=  src2 and "11111111";
		sb_a1 <= STD_LOGIC_VECTOR (SIGNED(src1) + SIGNED(Imm11_0S));

		-- Prepare index and data to write into register file
		reg_write_id <= rd;							

```


执行阶段，当满足某条指令条件时执行该指令。

```vhdl
		addresult <= STD_LOGIC_VECTOR(SIGNED(src1) + SIGNED(src2));
		--subresult <= STD_LOGIC_VECTOR(SIGNED(src1) - SIGNED(src2));
		jalresult <= STD_LOGIC_VECTOR(UNSIGNED(pc)+4);    
		xoriresult <= STD_LOGIC_VECTOR(SIGNED(src1) or SIGNED(Imm11_0I));
		reg_write_data <= addresult when opcode = "0110011" and funct7 = "0000000" else
						  --subresult when opcode = "0110011" and funct7 = "0100000" else
						  jalresult when opcode = "1101111" else
					      --blturesult when opcode = "1100011" and funct3 = "110" else
					      --sbresult when opcode = "0100011" and funct3 = "000" else
					      xoriresult when opcode = "0010011" and funct3 = "100" else
					     "00000000000000000000000000000000";
		data_addr <= sb_a1 when opcode = "0100011" and funct3 = "000";
		data_out <= sb_d1 when	opcode = "0100011" and funct3 = "000";	    
		next_pc <= STD_LOGIC_VECTOR(UNSIGNED(pc) + UNSIGNED(Imm20_1J)) when opcode = "1101111" else
			       STD_LOGIC_VECTOR(UNSIGNED(pc) + UNSIGNED(Imm12_1B))  when opcode = "1100011" and funct3 = "110" and (SIGNED(src1) < SIGNED(src2)) else
			       STD_LOGIC_VECTOR(UNSIGNED(pc)+4);
```

reg_write为写操作的标记，当为'1'时表示需要将reg_write_data的值写入下标为reg_write_id的寄存器中。

```vhdl
	signal reg_write: std_logic;
	signal reg_write_id: std_logic_vector(4 downto 0);
	signal reg_write_data: std_logic_vector(31 downto 0);
```



最后写回阶段，当时钟上跳时触发。

```vhdl
	-- Update pc and register file at rising edge of clk
	process(clk)
	begin
		if(rising_edge(clk)) then
			if (reset='1') then
				pc <= "00000000000000000000000000000000";
				-- Clear register file?
			else
				pc <= next_pc;

				if (reg_write = '1') then
					regs(TO_INTEGER(UNSIGNED(reg_write_id))) <= reg_write_data;
				end if; -- reg_write = '1'
			end if; -- reset = '1'
		end if; -- rising_edge(clk)
	end process; -- clk
```
## 测试

### 测试平台

模拟器在如下机器上进行了测试：

| 部件     |       配置       |  备注  |
| :------- | :--------------: | :----: |
| CPU      |  core M3   |        |
| 内存     |     DDR4 4GB     |        |
| 操作系统 | Windows10家庭版 | 中文版 |

### 测试记录

core部分的testbench运行的截图如下：

alu部分的testbench运行的截图如下：

decoder部分的testbench运行的截图如下：


## 分析和结论

从测试记录的截图结果可以看到，

